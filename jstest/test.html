<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Mini Tekken-ish Fighter</title>
<style>
  body { display:flex; align-items:center; justify-content:center; height:100vh; margin:0; background:#111; color:#eee; font-family:Arial,Helvetica,sans-serif; }
  #gameWrap { text-align:center; }
  canvas { background: linear-gradient(#6aa,#4a6); border:4px solid #222; display:block; margin:0 auto 10px; }
  .hud { display:flex; justify-content:space-between; width:720px; margin:6px auto; }
  .bar { width:300px; height:22px; background:#333; border-radius:4px; overflow:hidden; position:relative; }
  .hp { height:100%; background:linear-gradient(#ff8080,#ff3b3b); width:100%; transition:width .15s linear; }
  #controls { font-size:12px; color:#ccc; margin-top:8px; }
  button { padding:6px 10px; margin-left:8px; }
</style>
</head>
<body>
<div id="gameWrap">
  <div class="hud">
    <div>
      <div>Player 1</div>
      <div class="bar"><div id="hp1" class="hp"></div></div>
    </div>
    <div>
      <div>Player 2</div>
      <div class="bar"><div id="hp2" class="hp"></div></div>
    </div>
  </div>

  <canvas id="game" width="720" height="320"></canvas>

  <div id="status">Press A/D (move), W (jump), S (attack) for P1. ←/→ (move), ↑ (jump), ↓ (attack) for P2</div>
  <div id="controls">
    <button id="restartBtn">Restart</button>
    <label style="margin-left:20px">Round time: <span id="timeShow">60</span>s</label>
  </div>
</div>

<script>
/*
 Mini Tekken-ish 2D fighter
 - Two players (rectangles)
 - Movement, jump, attack (hitbox), health, knockback
 - Controls:
   Player1: A (left), D (right), W (jump), S (attack)
   Player2: ArrowLeft, ArrowRight, ArrowUp (jump), ArrowDown (attack)
*/

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const hp1bar = document.getElementById('hp1');
const hp2bar = document.getElementById('hp2');
const status = document.getElementById('status');
const restartBtn = document.getElementById('restartBtn');
const timeShow = document.getElementById('timeShow');

const W = canvas.width, H = canvas.height;
const GROUND_Y = H - 48;

let keys = {};
window.addEventListener('keydown', e => keys[e.key] = true);
window.addEventListener('keyup', e => keys[e.key] = false);

function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

// Player constructor
function Fighter(x, color, controls) {
  return {
    x, y: GROUND_Y - 64,
    w: 40, h: 64,
    vx:0, vy:0,
    dir: 1, // 1 = facing right, -1 = left
    onGround: true,
    color,
    health: 100,
    attackTimer: 0,      // attack active frames
    attackCooldown: 0,   // cooldown until next attack
    stun: 0,             // frames stunned from hit (cannot move)
    controls,
    score: 0
  };
}

// controls objects: { left:'a', right:'d', up:'w', down:'s' }
let p1 = Fighter(100, '#2ec4b6', {left:'a', right:'d', up:'w', down:'s'});
let p2 = Fighter(560, '#ff6b6b', {left:'ArrowLeft', right:'ArrowRight', up:'ArrowUp', down:'ArrowDown'});

let game = {
  running: true,
  roundTime: 60, // seconds
  timer: 60,
  lastTick: null,
};

// constants (tweak to balance)
const SPEED = 3.2;
const JUMP_FORCE = -10.5;
const GRAVITY = 0.6;
const ATTACK_DURATION = 18;   // frames active
const ATTACK_COOLDOWN = 36;   // frames until next attack allowed
const ATTACK_RANGE = 26;      // horizontal hitbox beyond fighter
const ATTACK_DAMAGE = 8;
const KNOCKBACK_X = 6;
const KNOCKBACK_Y = -6;

function resetGame() {
  p1 = Fighter(100, '#2ec4b6', {left:'a', right:'d', up:'w', down:'s'});
  p2 = Fighter(560, '#ff6b6b', {left:'ArrowLeft', right:'ArrowRight', up:'ArrowUp', down:'ArrowDown'});
  game.running = true;
  game.timer = game.roundTime;
  timeShow.innerText = game.timer;
  status.innerText = 'Fight!';
  updateHP();
}

// game loop
function update(t) {
  if (!game.lastTick) game.lastTick = t;
  const dt = (t - game.lastTick)/16.666; // ~frame factor (60fps)
  game.lastTick = t;

  if (game.running) {
    // convert dt into integer frames for logic stability
    const frames = Math.max(1, Math.round(dt));
    for (let i=0;i<frames;i++){
      tick();
    }
  }
  render();
  requestAnimationFrame(update);
}

function tick() {
  // round timer (count down each second)
  if (frameCount % 60 === 0) {
    game.timer = Math.max(0, game.timer - 1);
    timeShow.innerText = game.timer;
    if (game.timer <= 0) {
      endRound();
    }
  }

  updateFighter(p1, p2);
  updateFighter(p2, p1);

  frameCount++;
}

let frameCount = 0;

function updateFighter(me, opponent) {
  // reduce timers
  if (me.attackTimer > 0) me.attackTimer--;
  if (me.attackCooldown > 0) me.attackCooldown--;
  if (me.stun > 0) me.stun--;

  // handle inputs (only if not stunned)
  if (me.stun <= 0) {
    // left/right
    if (keys[me.controls.left]) {
      me.vx = -SPEED;
      me.dir = -1;
    } else if (keys[me.controls.right]) {
      me.vx = SPEED;
      me.dir = 1;
    } else {
      me.vx = 0;
    }

    // jump
    if (keys[me.controls.up] && me.onGround) {
      me.vy = JUMP_FORCE;
      me.onGround = false;
    }

    // attack (down key)
    if (keys[me.controls.down] && me.attackCooldown <= 0 && me.attackTimer <= 0) {
      me.attackTimer = ATTACK_DURATION;
      me.attackCooldown = ATTACK_COOLDOWN;
    }
  } else {
    // if stunned, partially slide slowly
    me.vx *= 0.9;
  }

  // physics
  me.vy += GRAVITY;
  me.x += me.vx;
  me.y += me.vy;

  // ground collision
  if (me.y + me.h >= GROUND_Y) {
    me.y = GROUND_Y - me.h;
    me.vy = 0;
    me.onGround = true;
  } else {
    me.onGround = false;
  }

  // keep inside arena
  me.x = clamp(me.x, 12, W - me.w - 12);

  // attacks: check overlap when attackTimer active and only once when it begins (we do per-frame; ensure not multiple hits using small hit cooldown)
  if (me.attackTimer > 0) {
    // compute attack hitbox
    const hx = me.dir === 1 ? me.x + me.w : me.x - ATTACK_RANGE;
    const hy = me.y + 12; // vertical offset
    const hw = ATTACK_RANGE;
    const hh = me.h - 24;

    // opponent rect
    const ox = opponent.x, oy = opponent.y, ow = opponent.w, oh = opponent.h;

    if (rectsOverlap(hx, hy, hw, hh, ox, oy, ow, oh)) {
      // apply damage and knockback — but only apply once per attack activation.
      // We'll mark attackTimer to a negative value to prevent repeat hits this activation.
      if (!me._hitRegistered) {
        opponent.health = Math.max(0, opponent.health - ATTACK_DAMAGE);
        opponent.vx = (me.dir === 1 ? KNOCKBACK_X : -KNOCKBACK_X);
        opponent.vy = KNOCKBACK_Y;
        opponent.stun = 18; // briefly stunned
        me._hitRegistered = true;
        updateHP();
        // small visual feedback
        spawnHitFlash(opponent.x + opponent.w/2, opponent.y + opponent.h/2);
        // Check if opponent is dead
        if (opponent.health <= 0) {
          endRound(me, opponent);
        }
      }
    } else {
      // if not overlapping this frame, keep possibility to hit later in same attack
      // do nothing
    }
  } else {
    // reset hit flag when attack fully finished
    me._hitRegistered = false;
  }
}

// rectangle overlap helper
function rectsOverlap(x1,y1,w1,h1,x2,y2,w2,h2){
  return !(x1+w1 < x2 || x1 > x2+w2 || y1+h1 < y2 || y1 > y2+h2);
}

// hit flash particles
let flashes = [];
function spawnHitFlash(x,y){
  flashes.push({x,y,life:18});
}

// end round either by time or death
function endRound(winner=null, loser=null){
  game.running = false;
  // determine winner if not provided by health
  if (!winner) {
    if (p1.health > p2.health) winner = p1, loser = p2;
    else if (p2.health > p1.health) winner = p2, loser = p1;
    else { status.innerText = 'Draw!'; return; }
  }
  status.innerText = (winner === p1 ? 'Player 1 wins!' : 'Player 2 wins!');
  document.getElementById('btn').disabled = true;
}

// draw world
function render(){
  // clear
  ctx.clearRect(0,0,W,H);

  // ground
  ctx.fillStyle = '#2b2';
  ctx.fillRect(0, GROUND_Y, W, H-GROUND_Y);

  // draw fighters
  drawFighter(p1);
  drawFighter(p2);

  // draw flashes
  for (let i=flashes.length-1;i>=0;i--){
    const f = flashes[i];
    ctx.save();
    ctx.globalAlpha = f.life/18;
    ctx.fillStyle = '#fff6';
    ctx.beginPath();
    ctx.arc(f.x, f.y, (18 - f.life) * 1.8 + 8, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
    f.life--;
    if (f.life <= 0) flashes.splice(i,1);
  }
}

// draw single fighter with simple attack animation
function drawFighter(p){
  // body
  ctx.fillStyle = p.color;
  ctx.fillRect(p.x, p.y, p.w, p.h);

  // face (simple)
  ctx.fillStyle = '#222';
  ctx.fillRect(p.x + (p.dir===1? p.w-10 : 4), p.y+10, 6, 6);

  // attack hitbox draw if active (for debugging / visual)
  if (p.attackTimer > 0) {
    ctx.fillStyle = 'rgba(255,255,0,0.25)';
    const hx = p.dir === 1 ? p.x + p.w : p.x - ATTACK_RANGE;
    const hy = p.y + 12;
    ctx.fillRect(hx, hy, ATTACK_RANGE, p.h - 24);
  }

  // small shadow
  ctx.fillStyle = 'rgba(0,0,0,0.25)';
  ctx.fillRect(p.x+6, GROUND_Y+2, p.w-12, 6);
}

// update hp bars in HUD
function updateHP(){
  hp1bar.style.width = p1.health + '%';
  hp2bar.style.width = p2.health + '%';
}

// restart handling
restartBtn.addEventListener('click', () => {
  resetGame();
  document.getElementById('btn').disabled = false;
});

// basic cheat button for joining automatic "btn" mapping used earlier (for overlay)
(function createClickButton(){
  // create an invisible button ID btn to match earlier disabling logic
  // It's for compatibility with your existing markup and "btn" id usage.
  const b = document.createElement('button');
  b.id = 'btn';
  b.style.position = 'absolute';
  b.style.left = '-9999px';
  document.body.appendChild(b);
})();

// initialize
resetGame();
requestAnimationFrame(update);

</script>
</body>
</html>
